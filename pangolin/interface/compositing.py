from pangolin.ir import Composite, Shape, Op
from pangolin.interface import InfixRV, makerv, normal, create_rv
from .vmapping import generated_nodes, AbstractOp
from pangolin import util
import jax.tree_util
from typing import Callable


def make_composite[LastOp: Op](flat_fun: Callable[..., InfixRV[LastOp]], *input_shapes: Shape) -> InfixRV[Composite[LastOp]]:
    """
    Given a function and input shapes, create a composite Op representing that function.
    Crucially, it *is* allowed for `fun` to depend on variables declared elsewhere through a closure.


    The final op expects as inputs *first* all the explicit inputs and then all the elements of consts

    Fun should not examine ops of its inputs.

    Parameters
    ----------
    flat_fun
        A function that takes RVs as inputs and returns a single RV
    input_shapes
        shapes for each explicit input to `fun`

    Returns
    -------
    op
        a Composite op representing the function. In the op, nodes are numbered starting
        at 0 for the variables captured through closure (returned as `consts`) then the
        explicit inputs, and then nodes generated by `flat_fun`. The final node represents
        the output.
    consts
        a list of constants that `flat_fun` captures through closures

    Examples
    --------
    >>> def fun(x, y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> op, consts = make_composite(fun, (), ())
    >>> op
    Composite(2, (Add(), Normal()), ((0, 1), (2, 1)))
    >>> consts
    []

    >>> x = makerv(3)
    >>> def fun(y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> op, consts = make_composite(fun, ())
    >>> op
    Composite(2, (Add(), Normal()), ((1, 0), (2, 0)))
    >>> consts
    [InfixRV(Constant(3))]
    """

    dummy_args = [InfixRV(AbstractOp(shape)) for shape in input_shapes]

    # generated_nodes runs on "flat" functions that return arrays, not single RVs
    f = lambda *args: [flat_fun(*args)]
    all_vars, [out] = generated_nodes(f, *dummy_args)
    assert isinstance(out, InfixRV), "output of function must be a single InfixRV"

    ops = []
    par_nums = []
    linear_order = {}

    for var in dummy_args:
        linear_order[var] = dummy_args.index(var)

    current_position = len(dummy_args)

    consts = []
    for var in all_vars:
        for p in var.parents:
            if p not in all_vars and p not in linear_order:
                linear_order[p] = current_position
                current_position += 1
                consts.append(p)

    num_inputs = current_position

    for var in all_vars:
        my_op = var.op
        my_par_nums = tuple(linear_order[p] for p in var.parents)
        ops.append(my_op)
        par_nums.append(my_par_nums)
        linear_order[var] = current_position
        current_position += 1

    return Composite(num_inputs, tuple(ops), tuple(par_nums)), consts


def composite_flat(flat_fun: Callable[..., InfixRV]) -> Callable[..., InfixRV[Composite]]:
    """Turn a function into a new function that returns a single Composite RV

    Parameters
    ----------
    flat_fun
        Function that takes any number of RVs as inputs and returns a single RV

    Examples
    --------
    >>> def f(x, y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> composite_flat(f)
    <function composite_flat.<locals>.myfun at ...>
    >>> x = makerv(1)
    >>> y = makerv(2)
    >>> z = composite_flat(f)(x, y)
    >>> z.op
    Composite(2, (Add(), Normal()), ((0, 1), (2, 1)))
    >>> z.parents == (x, y)
    True

    >>> # Example where x is not explicitly passed
    >>> def f(y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> z = composite_flat(f)(y)
    >>> z.op
    Composite(2, (Add(), Normal()), ((1, 0), (2, 0)))
    >>> z.parents == (x, y)
    True
    """

    def myfun(*inputs):
        input_shapes = [x.shape for x in inputs]
        op, consts = make_composite(flat_fun, *input_shapes)
        return create_rv(op, *consts, *inputs)

    return myfun


def composite(fun: Callable) -> Callable[..., InfixRV[Composite]]:
    """Turn a function into a new function that returns a single Composite RV. Typically this would be used to create autoregressive distributions via the `autoregressive` function, rather than called directly by the user.

    Parameters
    ----------
    fun
        Function that takes any number of RVs or pytrees of RVs and returns a single RV

    Examples
    --------
    >>> def f(stuff):
    ...     x = stuff['cat']
    ...     y = stuff['dog']
    ...     a = x+y
    ...     return normal(a, y)
    >>> composite(f)
    <function composite.<locals>.myfun at ...>
    >>> x = makerv(1)
    >>> y = makerv(2)
    >>> z = composite(f)({'cat':x, 'dog': y})
    >>> z.op
    Composite(2, (Add(), Normal()), ((0, 1), (2, 1)))
    >>> z.parents == (x, y)
    True

    >>> # Example where x is not explicitly passed
    >>> def f(stuff):
    ...     y = stuff['dog']
    ...     a = x+y
    ...     return normal(a, y)
    >>> z = composite(f)({'dog':y})
    >>> z.op
    Composite(2, (Add(), Normal()), ((1, 0), (2, 0)))
    >>> z.parents == (y, x)
    True
    """

    def myfun(*inputs):
        # this casts at the SMALLEST level - [0,0,0] becomes three scalars, not a vector
        # can't do more because level of granularity unclear
        inputs = jax.tree_util.tree_map(makerv, inputs)
        flat_fun, flatten_input, unflatten_output = util.flatten_fun(fun, *inputs)

        # remove first output, not list
        new_flat_fun = lambda *args: flat_fun(*args)[0]

        flat_inputs = flatten_input(*inputs)

        # test_out = new_flat_fun(*flat_inputs)
        # print(f"{test_out=}")

        flat_input_shapes = [x.shape for x in flat_inputs]
        op, consts = make_composite(new_flat_fun, *flat_input_shapes)
        return create_rv(op, *flat_inputs, *consts)

    return myfun


import functools


def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        "EXTRA INFO"
        return func(*args, **kwargs)

    return wrapper


# composite2 = my_decorator(composite)
# exec('composite5 = my_decorator(composite)')
# exec('composite5.__doc__ += "HEY"')

composite5 = my_decorator(composite)


def function_factory(name, description):
    """
    A factory that creates functions with dynamic docstrings.
    """

    def generated_function(*args, **kwargs):
        """
        This is a placeholder docstring. It will be overwritten.
        """
        print(f"Executing {name} with args: {args}, kwargs: {kwargs}")
        # Add your function's logic here
        return f"Result from {name}"

    # Set the docstring dynamically
    generated_function.__doc__ = f"This function is named '{name}'.\n\n{description}"

    # Optionally, set the function name for better introspection and pdoc display
    generated_function.__name__ = name
    generated_function.__qualname__ = name  # For nested functions or methods

    return generated_function


# Example usage:
my_func_a = function_factory("my_specific_function_A", "This function performs operation A.")
my_func_b = function_factory("my_specific_function_B", "This function handles data processing B.")


class MyBaseProcessor:
    """
    A base class for processing various types of data.

    Dynamically generated methods will be added to this class.
    """

    def __init__(self, data_source):
        """
        Initializes the processor with a data source.

        Args:
            data_source (str): The source of the data to be processed.
        """
        self.data_source = data_source
        print(f"MyBaseProcessor initialized with data source: {self.data_source}")

    def get_data_source(self):
        """
        Returns the data source string.
        """
        return self.data_source


# --- Factory Function for Dynamic Methods ---


def method_factory(method_name, method_docstring, method_logic_func):
    """
    A factory function to create a method (function) with proper attributes
    for dynamic assignment to a class.

    Args:
        method_name (str): The name of the method.
        method_docstring (str): The docstring content for the method.
        method_logic_func (callable): The actual Python function implementing the method's logic.
                                      It must accept 'self' as its first argument.

    Returns:
        callable: The prepared method function.
    """

    def generated_method(self, *args, **kwargs):
        """
        This is a placeholder docstring. It will be overwritten.
        """
        return method_logic_func(self, *args, **kwargs)

    # Set the docstring
    generated_method.__doc__ = method_docstring

    # Set the name (important for introspection and pdoc)
    generated_method.__name__ = method_name

    # Crucial for pdoc: Set the __qualname__ to include the class name.
    # We'll set this *after* we know which class it's being added to.
    # For now, we'll leave it as just the method_name, and update it later.
    # Alternatively, you could pass the class name to the factory, but
    # setting it during assignment is often cleaner.
    generated_method.__qualname__ = method_name  # Will be updated later

    return generated_method


# --- Dynamic Method Assignment ---

# Define specifications for the methods we want to add
method_specs = [
    {
        "name": "process_csv",
        "doc": "Processes data from a CSV file source.\n\nReturns: bool: True if processing was successful.",
        "logic": lambda self: f"Processing CSV from {self.data_source}...",
    },
    {
        "name": "process_json",
        "doc": "Processes data from a JSON API source.\n\nArgs:\n    api_key (str): The API key for authentication.\n\nReturns: dict: The parsed JSON data.",
        "logic": lambda self, api_key: {
            "status": "processed",
            "source": self.data_source,
            "key_used": api_key,
        },
    },
    {
        "name": "log_activity",
        "doc": "Logs a specific activity.\n\nArgs:\n    activity (str): The activity to log.\n\nReturns: None",
        "logic": lambda self, activity: print(f"[{self.data_source}] Logging activity: {activity}"),
    },
]

# Loop through the specs and add methods to MyBaseProcessor
for spec in method_specs:
    method_name = spec["name"]
    method_doc = spec["doc"]
    method_logic = spec["logic"]

    # Create the method using the factory
    dynamic_method = method_factory(method_name, method_doc, method_logic)

    # --- THIS IS THE CRUCIAL STEP FOR ASSIGNING TO THE CLASS ---
    # Assign the generated method to the class as an attribute.
    setattr(MyBaseProcessor, method_name, dynamic_method)

    # Update the __qualname__ to reflect its new home (the class)
    # This is vital for pdoc to show it as MyBaseProcessor.method_name
    dynamic_method.__qualname__ = f"MyBaseProcessor.{method_name}"
