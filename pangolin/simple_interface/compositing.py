from pangolin.ir import Composite, RV
from pangolin.simple_interface import InfixRV, makerv, normal, create_rv
from .vmapping import generated_nodes, AbstractOp
from pangolin import util
import jax.tree_util
from typing import Callable

def make_composite(flat_fun: Callable[..., RV], *input_shapes: tuple[int, ...]):
    """
    Given a function and input shapes, create a composite Op representing that function.
    Crucially, it *is* allowed for `fun` to depend on variables declared elsewhere through a closure.


    The final op expects as inputs *first* all the explicit inputs and then all the elements of consts

    Fun should not examine ops of its inputs.

    Parameters
    ----------
    flat_fun
        A function that takes RVs as inputs and returns a single RV
    input_shapes: tuple[int, ...]
        shapes for each explicit input to `fun`
    
    Returns
    -------
    op
        a Composite op representing the function. In the op, nodes are numbered starting
        at 0 for the variables captured through closure (returned as `consts`) then the
        explicit inputs, and then nodes generated by `flat_fun`. The final node represents
        the output.
    consts
        a list of constants that `flat_fun` captures through closures

    Examples
    --------
    >>> def fun(x, y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> op, consts = make_composite(fun, (), ())
    >>> op
    Composite(2, (Add(), Normal()), ((0, 1), (2, 1)))
    >>> consts
    []

    >>> x = makerv(3)
    >>> def fun(y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> op, consts = make_composite(fun, ())
    >>> op
    Composite(2, (Add(), Normal()), ((1, 0), (2, 0)))
    >>> consts
    [InfixRV(Constant(3))]
    """

    dummy_args = [InfixRV(AbstractOp(shape)) for shape in input_shapes]

    # generated_nodes runs on "flat" functions that return arrays, not single RVs
    f = lambda *args: [flat_fun(*args)]
    all_vars, [out] = generated_nodes(f, *dummy_args)
    assert isinstance(out, RV), "output of function must be a single InfixRV"

    ops = []
    par_nums = []
    linear_order = {}

    for var in dummy_args:
        linear_order[var] = dummy_args.index(var)

    current_position = len(dummy_args)

    consts = []
    for var in all_vars:
        for p in var.parents:
            if p not in all_vars and p not in linear_order:
                linear_order[p] = current_position
                current_position += 1
                consts.append(p)

    num_inputs = current_position

    for var in all_vars:
        my_op = var.op
        my_par_nums = tuple(linear_order[p] for p in var.parents)
        ops.append(my_op)
        par_nums.append(my_par_nums)
        linear_order[var] = current_position
        current_position += 1

    return Composite(num_inputs, tuple(ops), tuple(par_nums)), consts

def composite_flat(flat_fun: Callable[..., RV]):
    """Turn a function into a new function that returns a single Composite RV

    Parameters
    ----------
    flat_fun
        Function that takes any number of RVs as inputs and returns a single RV

    Examples
    --------
    >>> def f(x, y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> composite_flat(f)
    <function composite_flat.<locals>.myfun at ...>
    >>> x = makerv(1)
    >>> y = makerv(2)
    >>> z = composite_flat(f)(x, y)
    >>> z.op
    Composite(2, (Add(), Normal()), ((0, 1), (2, 1)))
    >>> z.parents == (x, y)
    True

    >>> # Example where x is not explicitly passed
    >>> def f(y):
    ...     a = x+y
    ...     return normal(a, y)
    >>> z = composite_flat(f)(y)
    >>> z.op
    Composite(2, (Add(), Normal()), ((1, 0), (2, 0)))
    >>> z.parents == (x, y)
    True
    """

    def myfun(*inputs):
        input_shapes = [x.shape for x in inputs]
        op, consts = make_composite(flat_fun,*input_shapes)
        return create_rv(op, *consts, *inputs)
    return myfun

def composite(fun):
    """Turn a function into a new function that returns a single Composite RV. Typically this would be used to create autoregressive distributions via the `autoregressive` function, rather than called directly by the user.

    Parameters
    ----------
    fun
        Function that takes any number of RVs or pytrees of RVs and returns a single RV

    Examples
    --------
    >>> def f(stuff):
    ...     x = stuff['cat']
    ...     y = stuff['dog']
    ...     a = x+y
    ...     return normal(a, y)
    >>> composite(f)
    <function composite.<locals>.myfun at ...>
    >>> x = makerv(1)
    >>> y = makerv(2)
    >>> z = composite(f)({'cat':x, 'dog': y})
    >>> z.op
    Composite(2, (Add(), Normal()), ((0, 1), (2, 1)))
    >>> z.parents == (x, y)
    True

    >>> # Example where x is not explicitly passed
    >>> def f(stuff):
    ...     y = stuff['dog']
    ...     a = x+y
    ...     return normal(a, y)
    >>> z = composite(f)({'dog':y})
    >>> z.op
    Composite(2, (Add(), Normal()), ((1, 0), (2, 0)))
    >>> z.parents == (y, x)
    True
    """

    def myfun(*inputs):
        # this casts at the SMALLEST level - [0,0,0] becomes three scalars, not a vector
        # can't do more because level of granularity unclear
        inputs = jax.tree_util.tree_map(makerv, inputs)
        flat_fun, flatten_input, unflatten_output = util.flatten_fun(fun, *inputs)

        # remove first output, not list
        new_flat_fun = lambda *args: flat_fun(*args)[0]

        flat_inputs = flatten_input(*inputs)

        #test_out = new_flat_fun(*flat_inputs)
        #print(f"{test_out=}")

        flat_input_shapes = [x.shape for x in flat_inputs]
        op, consts = make_composite(new_flat_fun, *flat_input_shapes)
        return create_rv(op, *flat_inputs, *consts)

    return myfun

